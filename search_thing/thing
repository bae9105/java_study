멀티쓰레드와 멀티프로세스 차이점

멀티프로세스
다수의 프로세스를 실행하는 것
하나의 프로세스는 크게 코드, 데이터, 스택, 힙 4가지 영역으로 이루어져있음
하나 이상의 프로세스들을 동시에 처리(병렬)

멀티쓰레드
하나의 프로세스를 다수의 실행 단위로 나누어 실행하는 것
코드, 데이터, 힙 영역을 공유하고 있으며, Stack만 스레드 별로 가짐
스레드란 한 프로세스 내에서 동작되는 여러 실행의 흐름으로 프로세스 하나에 자원을 공유하면서 일련의 과정을 여러 개를 동시에 실행시킬 수 있는 것

프로젝트 방법론
워터폴
요구분석 → 설계 → 개발 -> 테스트 순으로 순차적으로 이어지는 흐름
워터폴 모델은 오랜 기간 사용된 기법이니만큼 적용 사례가 많고, 단계별로 정형화된 접근방식을 사용하는 이유로 기술적인 위험 요소가 적다는 장점
정해진 순서대로 각 파트의 업무가 분장되고 관리되기 때문에 프로세스 상의 마일스톤을 정하는 것이 비교적 쉬운 편이라는 것도 장점

실제로 각 단의 경계를 명확히 구분하고, 앞선 파트의 업무가 완전히 끝난 후 다음 단계를 시작하는 것이 거의 불가능하다는 문제

애자일
애자일 모델은 전체적인 플랜을 짜고 문서를 통해 주도해 나가던 과거의 방식(워터폴 모델)과 달리 앞을 예측하며 개발하지 않고,
일정한 주기를 가지고 끊임없이 프로토 타입을 만들어 내며 필요할 때마다 요구사항을 더하고 수정하여 커다란 소프트웨어를 개발해 나가는 방식
기능이 실제로 구동되는 모습을 확인하고, 수정요청을 하거나 다음 단계로 넘어가는 긴밀한 관계를 형성할 수 있는 것
고객이 수많은 변경사항을 검토해야 하는 번거로움이 발생

함수형 프로그래밍(Functional Programming)
무엇을 구현하겠다에 초점을 두어, 자료 처리를 수학적인 함수의 계산으로 취급하고
상태와 가변적인 데이터를 배제하는 프로그래밍
실행 순서를 지정할 필요가 없기 때문에 비절차형 언어

장점 : 사이드이펙트를 미연에 방지한다. 객체지향보다 코드가 간결하다.
비절차형이라 평가 시점이 중요하지 않다. 테스트가 쉽다.(1회만으로 신뢰성 보장) 데이터형에 구애받지 않는다.
단점 : 상태를 조작할 수 없다.

객체지향 프로그래밍(OOP)(Object-Oriented Programming)
객체 중심적인 사고이며, 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고,
객체 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법

추상화 : 공통적인 속성이나 기능을 묶어서 이름을 붙이는 것
캡슐화 : 데이터를 은닉하고 데이터 기능을 노출시키지 않는다
상속성 : 가장 중요한 특징. 하나의 클래스가 가진 특징(데이터, 함수)을 그대로 다른 클래스에 물려줄때 사용된다 (부모의 메소드나 변수를 사용할 수 있어요)
다형성 : 같은 함수가 있어도 매개변수에 따라 각자 다른 일을 하는 것
객체지향 프로그래밍은 모듈 재사용 등으로 인해 확장 및 유지보수에 상대적으로 용이

장점 : 코드의 재사용이 가능하다. 분석과 설계의 전환이 쉽다.
단점 : 처리 속도가 상대적으로 다소 느리다. 설계의 많은 시간이 소요되며 설계를 잘못하면 다시 처음부터 짜야한다. 테스트가 어렵다.

절차지향 프로그래밍(Procedure-Oriented Programming)
일이 진행되는 순서대로 프로그래밍을 하는 방법
장점 : 코드를 따라가며 읽기가 쉬우며 작성하기에도 쉬운 편이다. 컴퓨터의 처리구조와 비슷해 실행 속도가 빠르다.
단점 : 각각의 코드가 순서에 민감하게 연결되어있어 유지보수가 쉽지 않다. 프로그램을 분석하기가 어렵다.


해쉬

부트스트랩
mysql 장/단점
mssql 장/단점
oracle 장/단점
mariadb 장/단점

알고리즘 문제 풀기

배운알고리즘으로 테스트샘플 만들기

REST API 만들어보기

REST API
gRPC

json
일반적으로 서버에서 클라이언트로 데이터를 보낼 때 사용하는 양식.
클라이언트가 사용하는 언어에 관계 없이 통일된 데이터를 주고받을 수 있도록,
일정한 패턴을 지닌 문자열을 생성해 내보내면 클라이언트는 그를 해석해 데이터를 자기만의 방식으로 온전히 저장, 표시할 수 있게 된다.
과거 웹 초기 시절부터 사용되어 온 XML은 헤더와 태그 등의 여러 요소로 가독성이 떨어지고, 쓸데없이 용량을 잡아먹는다는 단점이 항상 지적되어 왔다.
이에 대응해 간결하고 통일된 양식으로 각광을 받고 있는 것이 JSON이다.
［］안의 것은 순서가 있는 배열,
｛｝안의 것은 속성명(흔히 이름표라고 한다)이 있는 객체를 의미하며,
객체 안에 객체를 넣을 수도 있어서 XML처럼 복잡한 구조 또한 표현이 가능

문법 오류에 민감하다.
주석을 지원하지 않는다. 그래서 설정 파일을 JSON으로 작성하는 것은 어렵다.
데이터 타입을 강제할 수 없다.

http오류
1XX
정보 전달: 요청을 받았고, 작업을 진행 중이라는 의미

2XX
성공: 이 작업을 성공적으로 받았고, 이해했으며, 받아들여졌다는 의미
200 OK: 성공적으로 처리했을 때 쓰인다. 가장 일반적으로 볼 수 있는 HTTP 상태.

3XX
리다이렉션: 이 요청을 완료하기 위해서는 리다이렉션이 이루어져야 한다는 의미

4XX
클라이언트 오류: 이 요청은 올바르지 않다는 의미
400 Bad Request(잘못된 요청): 요청 자체가 잘못되었을 때 사용하는 코드
403 Forbidden(거부됨): 서버가 요청을 거부할 때 발생
404 Not Found(찾을 수 없음): 찾는 리소스가 없다는 뜻으로, 가장 흔하게 볼 수 있는 오류 코드
408 Request Timeout(요청 시간 초과) : 요청 중 시간이 초과되었을때 사용하는 코드

5XX
서버 오류: 올바른 요청에 대해 서버가 응답할 수 없다는 의미
500 Internal Server Error(내부 서버 에러): 서버에 오류가 발생해 작업을 수행할 수 없을 때 사용
502 Bad Gateway: 게이트웨이가 연결된 서버로부터 잘못된 응답을 받았을 때 사용
503 Service Temporarily Unavailable(일시적으로 서비스를 이용할 수 없음): 서비스를 일시적으로 사용할 수 없을 때 사용
504 Gateway Timeout(게이트웨이 시간초과): 게이트웨이가 연결된 서버로부터 응답을 받을 수 없었을 때 사용


