멀티쓰레드와 멀티프로세스 차이점

멀티프로세스
다수의 프로세스를 실행하는 것
하나의 프로세스는 크게 코드, 데이터, 스택, 힙 4가지 영역으로 이루어져있음
하나 이상의 프로세스들을 동시에 처리(병렬)

멀티쓰레드
하나의 프로세스를 다수의 실행 단위로 나누어 실행하는 것
코드, 데이터, 힙 영역을 공유하고 있으며, Stack만 스레드 별로 가짐
스레드란 한 프로세스 내에서 동작되는 여러 실행의 흐름으로 프로세스 하나에 자원을 공유하면서 일련의 과정을 여러 개를 동시에 실행시킬 수 있는 것

프로젝트 방법론
워터폴
요구분석 → 설계 → 개발 -> 테스트 순으로 순차적으로 이어지는 흐름
워터폴 모델은 오랜 기간 사용된 기법이니만큼 적용 사례가 많고, 단계별로 정형화된 접근방식을 사용하는 이유로 기술적인 위험 요소가 적다는 장점
정해진 순서대로 각 파트의 업무가 분장되고 관리되기 때문에 프로세스 상의 마일스톤을 정하는 것이 비교적 쉬운 편이라는 것도 장점

실제로 각 단의 경계를 명확히 구분하고, 앞선 파트의 업무가 완전히 끝난 후 다음 단계를 시작하는 것이 거의 불가능하다는 문제

애자일
애자일 모델은 전체적인 플랜을 짜고 문서를 통해 주도해 나가던 과거의 방식(워터폴 모델)과 달리 앞을 예측하며 개발하지 않고,
일정한 주기를 가지고 끊임없이 프로토 타입을 만들어 내며 필요할 때마다 요구사항을 더하고 수정하여 커다란 소프트웨어를 개발해 나가는 방식
기능이 실제로 구동되는 모습을 확인하고, 수정요청을 하거나 다음 단계로 넘어가는 긴밀한 관계를 형성할 수 있는 것
고객이 수많은 변경사항을 검토해야 하는 번거로움이 발생

함수형 프로그래밍(Functional Programming)
무엇을 구현하겠다에 초점을 두어, 자료 처리를 수학적인 함수의 계산으로 취급하고
상태와 가변적인 데이터를 배제하는 프로그래밍
실행 순서를 지정할 필요가 없기 때문에 비절차형 언어

장점 : 사이드이펙트를 미연에 방지한다. 객체지향보다 코드가 간결하다.
비절차형이라 평가 시점이 중요하지 않다. 테스트가 쉽다.(1회만으로 신뢰성 보장) 데이터형에 구애받지 않는다.
단점 : 상태를 조작할 수 없다.

객체지향 프로그래밍(OOP)(Object-Oriented Programming)
객체 중심적인 사고이며, 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고,
객체 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법

추상화 : 공통적인 속성이나 기능을 묶어서 이름을 붙이는 것
캡슐화 : 데이터를 은닉하고 데이터 기능을 노출시키지 않는다
상속성 : 가장 중요한 특징. 하나의 클래스가 가진 특징(데이터, 함수)을 그대로 다른 클래스에 물려줄때 사용된다 (부모의 메소드나 변수를 사용할 수 있어요)
다형성 : 같은 함수가 있어도 매개변수에 따라 각자 다른 일을 하는 것
객체지향 프로그래밍은 모듈 재사용 등으로 인해 확장 및 유지보수에 상대적으로 용이

장점 : 코드의 재사용이 가능하다. 분석과 설계의 전환이 쉽다.
단점 : 처리 속도가 상대적으로 다소 느리다. 설계의 많은 시간이 소요되며 설계를 잘못하면 다시 처음부터 짜야한다. 테스트가 어렵다.

절차지향 프로그래밍(Procedure-Oriented Programming)
일이 진행되는 순서대로 프로그래밍을 하는 방법
장점 : 코드를 따라가며 읽기가 쉬우며 작성하기에도 쉬운 편이다. 컴퓨터의 처리구조와 비슷해 실행 속도가 빠르다.
단점 : 각각의 코드가 순서에 민감하게 연결되어있어 유지보수가 쉽지 않다. 프로그램을 분석하기가 어렵다.


해쉬

부트스트랩
mysql 장/단점
mssql 장/단점
oracle 장/단점
mariadb 장/단점

알고리즘 문제 풀기

배운알고리즘으로 테스트샘플 만들기

REST API 만들어보기

REST API
gRPC

json
일반적으로 서버에서 클라이언트로 데이터를 보낼 때 사용하는 양식.
클라이언트가 사용하는 언어에 관계 없이 통일된 데이터를 주고받을 수 있도록,
일정한 패턴을 지닌 문자열을 생성해 내보내면 클라이언트는 그를 해석해 데이터를 자기만의 방식으로 온전히 저장, 표시할 수 있게 된다.
과거 웹 초기 시절부터 사용되어 온 XML은 헤더와 태그 등의 여러 요소로 가독성이 떨어지고, 쓸데없이 용량을 잡아먹는다는 단점이 항상 지적되어 왔다.
이에 대응해 간결하고 통일된 양식으로 각광을 받고 있는 것이 JSON이다.
［］안의 것은 순서가 있는 배열,
｛｝안의 것은 속성명(흔히 이름표라고 한다)이 있는 객체를 의미하며,
객체 안에 객체를 넣을 수도 있어서 XML처럼 복잡한 구조 또한 표현이 가능

문법 오류에 민감하다.
주석을 지원하지 않는다. 그래서 설정 파일을 JSON으로 작성하는 것은 어렵다.
데이터 타입을 강제할 수 없다.

http오류
1XX
정보 전달: 요청을 받았고, 작업을 진행 중이라는 의미

2XX
성공: 이 작업을 성공적으로 받았고, 이해했으며, 받아들여졌다는 의미
200 OK: 성공적으로 처리했을 때 쓰인다. 가장 일반적으로 볼 수 있는 HTTP 상태.

3XX
리다이렉션: 이 요청을 완료하기 위해서는 리다이렉션이 이루어져야 한다는 의미

4XX
클라이언트 오류: 이 요청은 올바르지 않다는 의미
400 Bad Request(잘못된 요청): 요청 자체가 잘못되었을 때 사용하는 코드
403 Forbidden(거부됨): 서버가 요청을 거부할 때 발생
404 Not Found(찾을 수 없음): 찾는 리소스가 없다는 뜻으로, 가장 흔하게 볼 수 있는 오류 코드
408 Request Timeout(요청 시간 초과) : 요청 중 시간이 초과되었을때 사용하는 코드

5XX
서버 오류: 올바른 요청에 대해 서버가 응답할 수 없다는 의미
500 Internal Server Error(내부 서버 에러): 서버에 오류가 발생해 작업을 수행할 수 없을 때 사용
502 Bad Gateway: 게이트웨이가 연결된 서버로부터 잘못된 응답을 받았을 때 사용
503 Service Temporarily Unavailable(일시적으로 서비스를 이용할 수 없음): 서비스를 일시적으로 사용할 수 없을 때 사용
504 Gateway Timeout(게이트웨이 시간초과): 게이트웨이가 연결된 서버로부터 응답을 받을 수 없었을 때 사용


오버로딩
메서드의 이름은 같고 매개변수의 유형과 개수가 다르도록 하는 것을 의미합니다.
- 리턴값만을 다르게 갖는 오버로딩은 작성 할 수 없습니다.

오버라이딩
상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의해서 사용 하는것을 의미합니다.
- 메서드의 이름은 물론 파라메터의 갯수나 타입도 동일해야 하며, 주로 상위 클래스의 동작을 상속받은 하위 클래스에서 변경하기 위해 사용됩니다.

생성자(Constructor)

생성자는 new 연산자를 통해서 인스턴스를 생성할 때 반드시 호출이 되고 제일 먼저 실행되는 일종의 메소드(하지만 메소드와는 다르다.)이다.
생성자는 인스턴스 변수(필드 값 등)를 초기화 시키는 역할
생성자를 생략하면 컴파일러가 자동적으로 기본 생성자(Default Constructor)를 생성.
Default 생성자란 "public 클래스(){ }"를 의미

참고로 생성자의 매개변수를 다르게 지정하여 정의하는 것을 생성자 오버로딩이라고 한다.

생성자의 특징(메소드와의 차이)
생성자는 반드시 클래스명과 동일하게 정의하여야 한다. 생성자 앞에는 접근 제어자(public 등)만 올수 있다.
(메소드는 static과 같은 수식어를 작성할 수 있다.)
반환값이 없으므로 void나 자료형을 작성할 수 없다.
(메소드는 void나 자료형이 있어야 한다.)


메서드
선언
메서드는 크게 선언부와 구현부로 나뉘어짐
메서드 선언부는 반환타입, 메서드 이름, 매개변수 선언으로 구성

구현부
메서드 선언부 이후에 오는 괄호 {} 를 메서드 구현부라고 부름
메서드에서 수행해야 하는 실질적인 코드(로직)이 담겨있음
메서드의 반환타입이 void가 아닌 경우에 구현부 가장 아래에는 ‘return 반환값’이 반드시 포함되어야 함
반환값의 타입은 메서드 선언부에서 선언한 반환타입과 일치해야함 함

호출
자신이 만든 메서드 또는 라이브러리에서 이미 구현된 메서드를 호출할 수 있음
메서드를 호출하는 방법은 메서드 이름과 괄호 안에 인자 값을 넣으면 됨
인자 값은 메서드에 선언된 매개변수의 순서와 타입이 일치해야

상속
상속은 기존 정의된 클래스를 재사용해서 새로운 클래스를 작성(확장)하는 것을 의미한다.
상속을 이용하면 새로운 클래스를 정의할 때 적은 양의 코드 작성을 해도 되고, 공통적인 기능을 같이 사용할 수 있다.
자바에서 상속은 extends 키워드를 함께 사용하면 된다. 예를 들어 부모와 자식 클래스가 있다고 생각하자.
자식 클래스는 부모 클래스를 상속 받아서 부모가 사용할 수 있는 속성, 기능을 물려 받는다.
자바는 단일 상속만 가능

Object 클래스
Object 클래스는 모든 클래스 상속 계층도에서 가장 최상위에 있는 부모 클래스이다.
우리는 클래스를 정의할 때 extends 키워드를 써서 Object를 선언하지 않았다.
컴파일러는 다른 클래스를 상속 받지 않는 모든 클래스들을 자동적으로 Object 클래스를 상속 받도록 변경한다.

추상 클래스(abstract class)
추상 클래스는 abstract 키워드를 붙인 클래스이다.
다른 점으로는 추상 클래스로는 인스턴스화 해서 객체를 생성할 수 없다.
추상 클래스에는 미완성된 메서드를 포함하고 있다.
미완성 메서드란 메서드를 선언만 하고 구현부에 로직을 채우지 않은 형태를 말한다.
추상 클래스의 용도는 새로운 클래스를 작성하는데 부모 클래스로 사용되기 때문에 유용하다.
추상 클래스는 일반 클래스처럼 생성자가 있으며, 멤버변수, 메서드 모두 가질 수 있다.

인터페이스(interface)
인터페이스는 class가 아닌 interface 키워드를 사용해서 정의한다.
인터페이스 용도는 특정 기능에 대한 정의를 하는 것이다.
추상클래스와 차이점으로는 일반 메서드와 멤버 변수를 가질 수 없다.
인터페이스는 추상 메서드, 디폴트 메서드, 정적 메서드, 상수를 가질 수 있다.

추상 클래스와 인터페이스
추상 클래스와 인터페이스가 하는 일은 비슷하게 보일 수 있습니다.
다른 클래스가 추상 메서드를 구현하게 하는 역할을 하고 있기 때문입니다.
하지만 추상 클래스와 인터페이스의 존재 목적은 명확하게 다릅니다.
추상 클래스는 클래스가 상속 받아서 기능을 이용하고 확장하는데 중점이라고 하면,
인터페이스는 함수의 구현을 강제로 하게 하고 구현 객체의 같은 동작을 보장합니다.

내부 클래스 (inner class)
내부 클래스는 말 그대로 클래스 내부에 선언한 클래스이다.
클래스에 또 다른 클래스를 정의하는 이유는 두 개의 클래스가 서로 관련이 있기 때문이다.
내부 클래스에서는 감싸고 있는 클래스의 멤버 변수에 쉽게 접근이 가능하고, 외부에 있는 클래스는 내부 클래스의 존재를 감출 수 있다.

익명 클래스 (anonymous class)
익명 클래스는 이름이 없는 클래스이다. 이름이 없는 클래스를 어떻게 정의해야 할지 의문이 들 수 있을 것이다.
그리고 익명 클래스로는 클래스 이름 없이 객체를 생성할 수 있다.
익명 클래스는 클래스의 선언과 객체의 생성을 동시에 하기 때문에 한번만 사용될 수 있고, 오직 하나의 객체만을 생성하는 일회용 클래스이다.
클래스의 상속 또는 인터페이스를 구현할 수 있다.



접근 제어자 (access modifier)
접근제어자는 멤버 또는 클래스에 사용되어 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 함
접근제어자는 생략가능하며 생략했을 때는 자동으로 default 임을 뜻하게 된다. 따라서 default 일경우에는 접근제어자를 지정하지 않는다.
접근제어자가 사용될 수 있는 곳 : 클래스, 멤버변수, 메서드, 생성자
private : 같은 클래스 내에서만 접근 가능
default : 같은 패키지 내에서만 접근 가능
protected : 같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근 가능
public : 접근 제한이 없음
접근 범위 : private < default < protected < public 순으로 보다 많은 접근을 허용

접근 제어자를 이용한 캡슐화
접근 제어자를 사용하는 이유는 클래스의 내부에 선언된 데이터를 보호하기 위해서이다.
데이터가 유효한 값을 유지하도록 또는 비밀번호와 같은 데이터를 외부에서 함부로 변경하지 못하도록 하기 위해서는
외부로부터의 접근을 제한하는 것이 필요하다
이것을 데이터 감추기라고 하며 객체지향개념에선 캡슐화(encapsulation)이라 한다.

대상에 따라 사용할 수 있는 제어자
클래스
 public, (default), final, abstract
메서드
 모든 접근제어자, final, abstract, static
멤버변수
 모든 접근제어자, final, static
지역변수
 final

오류

Exception: 사용자의 실수와 같은 외적인 요인에 의해 발생하는 예외
RuntimeException: 프로그래머의 실수로 발생하는 예외

try-catch문
예외처리는 프로그램 실행 시 발생하는 예외에 대비해서 작성하는 코드를 말한다.
자바에서는 예외 처리 하기 위해서 try-catch 문을 사용한다.
예외를 처리함으로써 비정상 종료를 막고 정상적인 실행상태를 유지한다.

예외 발생
throw 키워드를 사용하면 고의로 예외를 발생시킬 수 있다.
고의로 예외를 발생시키는 경우는 시스템적인 오류보다는 논리적인 에러(탈퇴한 회원이 기능을 사용하려는 경우, 잔고가 없는데 인출을 하려는 경우 등)에
해당할 때, 프로그래머가 인위적으로 예외를 발생시킬 때 사용한다.

메서드 예외
특정 메서드에서 에러가 발생할 수 있다고 선언할 수 있다.
메서드 선언부에 throws 키워드와 발생할 수 있는 예외를 쉼표로 구분해서 정의하면 된다.

finally 블록
finally는 예외 발생여부 상관 없이 실행되어야 할 코드를 작성하기 위해서 사용된다.
try-catch문과 함께 사용하며, try-catch-finally 순서로 구성된다.
try 범위에서 예외가 발생하지 않으면, try-finally로 실행된다. finally는 예외 발생 상관 없이 항상 실행된다.
finally 블록에는 어떠한 자원을 해제하거나 또는 작업 이후에 수행되어야 할 후처리(임시 파일 삭제 등) 로직이 들어간다.

사용자 정의 예외 만들기
자바에서 기본적으로 제공하는 예외말고 프로그래머가 새로운 예외를 정의 해서 사용할 수 있다.
사용자 정의 예외를 만들게 되면 대부분 RuntimeException을 상속 받아서 unchecked exception으로 생성한다.
checked exception으로 작성하는 경우에 호출하는 쪽에서 반드시 예외처리를 해주어야 하기 때문에 코드가 복잡해진다.
반면 unchecked exception은 예외 처리를 선택적으로 할 수 있기 때문에 정말 필요한 예외만 처리해주면 된다.
kotlin은 checked exception으로 없애고 전부 unchecked exception으로 정의한다.

java.lang 패키지와 유틸 클래스
java.lang은 자바 프로그래밍에 필요한 가장 기본적인 클래스들이 모여있는 패키지이다.
유틸 클래스는 특정 상태를 갖고 있지 않는 클래스이며, 어떤 동작을 수행하는데 필요한 메서드를 미리 정의해 놓은 클래스이다.
덧셈, 뺄셈과 같은 동작은 흔한 기능이며, 프로그래머가 별도로 정의하지 않고 Math 유틸 클래스를 이용하면 계산기 기능을 쉽게 개발 할 수 있다.

자바 라이브러리에서 기본적으로 제공하는 패키지에 대해서 이해하고, 유틸 클래스를 잘 활용 해야 코드를 작성하는데 복잡성과 시간을 줄일 수 있다.

Object 클래스
Object 클래스는 모든 클래스의 부모 클래스이기 때문에 Object 클래스에 정의된 메서드를 사용 가능하다.

String 클래스
자바에서는 문자열을 위한 String 클래스를 제공한다.
문자열을 char 배열 형태로도 사용할 수 있지만, String 클래스를 사용하는 이유는 문자열 처리에 유용한 메서드를 제공하기 때문이다.

Math 클래스
Math 클래스는 기본적인 수학 계산에 사용되는 메서드를 제공하는 유틸 클래스이다.
Math 클래스는 생성자 접근 제어자가 private 이기 때문에 다른 클래스가 상속 또는 Math 객체를 생성할 수 없다.
모든 메서드는 static으로이며, 유틸 클래스 역할만 한다.

래퍼(Wrapper) 클래스
자바에서 제공하는 기본형 타입 8가지 종류는 객체로 다루지 않는다.
기본형 타입 8가지를 대표하는 8개 래퍼 클래스가 있다.
래퍼 클래스를 이용하면 기본형 값을 객체로 다룰 수 있다.
예를 들어 정수를 저장하는 기본형 타입인 int는 래퍼 클래스로 Integer로 된다.
래퍼 클래스로 다루면 좋은 점은 String 클래스처럼 유용한 메서드를 제공할 수 있다.

날짜 포맷
Date 날짜 객체를 원하는 형식으로 출력하기 위해서 SimpleDateFormat을 사용하면 된다.
SimpleDateFormat 객체를 생성할 때, 출력하고 싶은 날짜 포맷 문자열을 지정한다.

LocalDate, LocalTime 사용
LocalDate는 날짜를 표현하는 불변 객체다.
시간대 정보를 포함하지 않는 것이 특징이다.
LocalDate 객체를 생성하는 방법은 정적 팩토리 메서드 of 를 사용한다.
LocalTime은 시간을 표현하는 불변 객체다.
정적 메서드 of로  LocalTime 객체를 생성할 수 있다.

날짜와 시간을 문자열로 받은 다음에 LocalDate, LocalTime 객체를 생성하는 방법도 있다.
parse 정적 메서드를 사용하면 된다.
parse 메서드에 DateTimeFormatter를 전달해서 날짜, 시간 객체의 형식을 지정할 수 있다.
문자열을 LocalDate 또는 LocalTime으로 파싱할 수 없을 때 parse 메서드는 DateTimeParseException 예외를 던진다.
RuntimeException을 상속 받은 런타임 에러이기 때문에 try-catch 구문을 반드시 작성하지 않아도 된다.

LocalDateTime은 날짜와 시간을 모두 표현하는 클래스이다.
LocalDate와 LocalTime을 갖고 있는 복합 클래스이다.

Instant 클래스는 Unix epoch time(1970년 1월 1일 0시 0분 0초 UTC)을 기준으로 특정 지점까지의 시간을 초로 표현한다.
타임스탬프는 인간에게는 직관적이지 않은 시간의 표현 방법이지만 고전적으로 기계에게는 매우 친화적인 방법으로 현재까지 널리 사용되어 왔습니다.
팩토리 메서드 ofEpochSecond에 초를 넘겨줘서 Instant 객체를 생성할 수 있다.

Temporal 인터페이스는 특정 시간을 모델링하는 객체의 값을 어떻게 읽고 어떤 방식으로 조작할지 정의한다.
Duration과 Period는 두 시간 객체 사이의 기간(시간 또는 날짜)을 구하기 위해서 사용한다.
Duration은 두 시간 객체간에 시간 값을 생성할 수 있다.
Period는 두 시간 객체의 날짜 간격을 구할 때 사용한다.

DateTimeFormatter를 이용해서 날짜나 시간을 특정 형식의 문자열로 만들 수 있다.
반대로 날짜나 시간을 표현하는 문자열을 파싱해서 날짜 객체를 만들 수 있다.


제네릭 (Generics)
제네릭은 다양한 타입의 객체들을 다루는 메서드나 클래스에 컴파일 시의 타입 체크를 해주는 기능이다.
객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형 변환의 번거로움이 줄어든다.

타입 변수
ArrayList 클래스 이름 옆에 <> 안에 있는 E를 타입 변수(type variable)이라고 한다.
타입 변수가 여러개인 경우에 콤마(,)를 구분자로 나열하면 된다. 타입 변수를 사용하게 되면 특정 클래스를 다양한 타입의 객체를 사용할 수 있다.

제한된 제네릭 클래스
타입 문자로 사용할 타입을 명시하면 한 종류의 타입만 저장할 수 있도록 제한 할 수 있다.
다만, 모든 종류의 타입을 지정할 수 있다는 것에는 변함이 없기 때문에
타입 매개변수 T에 지정할 수 있는 타입의 종류를 제한하는 방법에 대해 알아보자.
와일드 카드
제네릭 타입에 다형성을 적용할 때는 와일드 카드를 사용하면 된다. 와일드 카드는 기호 ?를 사용하는데, 상한과 하한을 제한 할 수 있다.

제네릭 메서드
메서드의 선언부에 제네릭 타입이 선언된 메서드를 제네릭 메서드라고 한다.
Collections 클래스의 sort 메서드는 제네릭 메서드이다. 제네릭 타입의 선언 위치는 반환타입 앞에 위치한다.

제네릭 타입 제거
컴파일러는 제네릭 타입을 이용해서 소스 파일을 체크하고, 필요한 곳에 형변환을 넣어준다.
그런 다음에 제네릭 타입을 제거한다.
결국 컴파일 된 파일(.class)에는 제네릭 타입에 대한 정보가 없다.

열거형 (enum)
열거형은 여러 상수를 선언해야 할 때 자주 사용한다.
상수를 단순히 값으로 비교하게 되면, 서로 다른 타입이더라도 동일한 값이어서 true를 반환하게 된다.
이러한 경우에 열거형을 쓰게 되면 서로 다른 상수는 타입부터 다르기 때문에 컴파일 에러가 발생한다.

애노테이션
애노테이션은 주석(//, /**/)처럼 프로그래밍 언어에 영향을 미치지 않으면서 다른 프로그램에게 유용한 정보를 제공한다.
애노테이션은 JDK에서 기본적으로 제공하는 것을 사용해도 되고, 자신의 프로그램에 맞게 정의해서 사용해도 된다.
자바에서 기본적으로 제공하는 애노테이션이다.





타입 변수
ArrayList 클래스 이름 옆에 <> 안에 있는 E를 타입 변수(type variable)이라고 한다.
타입 변수가 여러개인 경우에 콤마(,)를 구분자로 나열하면 된다. 타입 변수를 사용하게 되면 특정 클래스를 다양한 타입의 객체를 사용할 수 있다.



프로세스와 쓰레드
프로세스란 실행 중인 프로그램을 말한다.
프로그램을 실행 하려면 OS로부터 실행에 필요한 자원을 할당 받아 프로세스가 된다.
프로세스는 프로그램을 수행하는 데 필요한 데이터, 메모리, 쓰레드 등으로 구성된다.
프로세스의 자원을 이용해서 실제로 작업을 수행하는 것이 쓰레드이다.
모든 프로세스에는 최소한 하나 이상의 쓰레드가 존재하며, 둘 이상의 쓰레드를 가진 프로세스를 ‘멀티쓰레드 프로세스’라고 한다.

쓰레드 구현 방법
자바에서 쓰레드를 구현하는 방법은 Thread 클래스를 상속하는 방법과 Runnable 인터페이스를 구현하는 방법 두 가지이다.
어느 방법을 사용해도 무방하지만 Thread 클래스를 상속 받으면 다른 클래스를 상속 받지 못한다는 문제점이 있다.
따라서 Runnable 인터페이스를 구현하는 방법이 일반적이다.

쓰레드 실행
쓰레드 객체를 생성했다고 자동으로 실행되는 것은 아니며, start() 메서드를 호출해야만 쓰레드가 실행된다.
start() 메서드를 호출해도 바로 실행 되는 것이 아니라 실행 대기 상태에 있다가 자신의 차례가 되어야 실행된다.
쓰레드의 실행 순서는 OS의 스케줄러가 작성한 스케줄에 의해 결정된다.
한 번 실행이 종료된 쓰레드는 다시 실행할 수 없다는 것을 유의해야 한다.

start() 와 run() 차이
main 메서드에서 run()을 호출하는 것은 생성된 쓰레드를 실행시키는 것이 아닌 단순히 클래스에 선언된 메서드를 호출하는 것이다.
반면에 start()는 새로운 쓰레드가 작업을 실행할 때 필요한 호출스택을 생성한 다음 run()을 호출한다.
모든 쓰레드는 독립적인 작업을 수행하기 위해서 자신만의 호출스택을 필요로 한다.
새로운 쓰레드를 생성하고 실행할 때마다 새로운 호출스택이 생성되고 소멸된다.

쓰레드 우선순위
쓰레드는 우선순위라는 멤버변수를 가지고 있다.
우선순위 값에 따라 쓰레드가 얻는 실행 시간이 달라진다.
우선순위에 따라 특정 쓰레드가 더 많은 작업 시간을 갖도록 할 수 있다.
쓰레드가 가질 수 있는 우선순위 범위는 1 ~ 10까지이며, 숫자가 높을수록 우선순위가 높다.

데몬 쓰레드
데몬 쓰레드는 일반 쓰레드의 작업을 돕는 보조적인 역할을 하는 쓰레드이다.
일반 쓰레드가 모두 종료되면, 데몬 쓰레드는 강제적으로 자동 종료된다.
데몬 쓰레드의 예로는 가비지 컬렉터, 워드프로세서의 자동저장, 화면 자동 갱신 등이 있다.
자바에서 데몬 쓰레드 생성 방법은 setDaemon 메서드를 true로 호출 해주면 된다.

쓰레드 실행 제어
쓰레드 프로그래밍이 어려운 이유는 동기화와 스케줄링 때문이다.
멀티 쓰레드 프로그램을 만들기 위해서는 프로세스에게 주어진 자원과 시간을 여러 쓰레드가 낭비없이 잘 사용하도록 프로그래밍 해야 한다.
쓰레드 스케줄링을 잘하기 위해서는 쓰레드의 상태와 관련된 메서드와 스케줄링 메서드를 알아야한다.

쓰레드 동기화
쓰레드가 진행 중인 작업을 다른 쓰레드가 간섭하지 못하도록 막는 것을 쓰레드의 동기화(synchronization)라고 한다.
자바에서는 synchronized 블록을 이용해서 쓰레드의 동기화를 지원했지만,
locks와 atomic 패키지를 통해서 다양한 방식으로 동기화를 구현할 수 있도록 지원하고 있다.

람다식 (Lambda Expression)
람다식은 메서드를 하나의 식(expression)으로 표현한 것을 말한다.
함수를 간단하며 명확하게 표현해주는게 장점이다.
메서드를 람다식으로 표현하면 메서드의 이름과 반환값이 없어지므로, 람다식을 익명 함수라고도 한다.

람다식 작성하기
메서드를 람다식으로 만들기 위해서는 메서드에서 이름과 반환타입을 제거하고 매개변수 선언부와 몸통 {} 사이에 ‘->’ 를 추가하면 된다.

함수형 인터페이스
람다식을 다루는 인터페이스를 함수형 인터페이스이다.
함수형 인터페이스에는 하나의 추상 메서드가 선언되어 있으며, 람다식으로 표현할 수 있다.
람다식은 실제로 익명 객체이고, 함수형 인터페이스에 선언된 메서드와 일치한다.

java.util.function 패키지
일반적으로 자주 쓰이는 형식의 메서드를 함수형 인터페이스로 미리 정의해놓은 패키지이다.
라이브러리에서 제공하는 함수형 인터페이스를 사용함으로써 이름 통일이 되고, 재사용, 유지보수 측면에서 좋다.

컬렉션 프레임워크와 함수형 인터페이스
컬렉션 프레임워크 인터페이스에 다수의 디폴트 메서드가 추가되었는데, 그 중 일부는 함수형 인터페이스를 사용한다.

메서드 참조
람다식이 하나의 메서드만 호출하는 경우에 메서드 참조(method reference) 방법으로 람다식을 간략히 할 수 있다.

스트림
지금까지 많은 수의 데이터를 다룰 때, 컬렉션 또는 배열에 데이터를 담고 원하는 결과를 얻기 위해 코드를 작성했다.
반면에 스트림은 이러한 문제점을 해결하고 데이터를 다루는 것에 초점을 둔다.
스트림의 또다른 장점은 데이터 소스를 추상화 했기 때문에 컬렉션 또는 배열 그리고 파일 등이어도 같은 방식으로 다룰 수 있다.
1. 데이터 구조가 아니다. 데이터의 흐름이다.
2. 데이터를 변경하지 않고 결과를 새로운 스트림에 저장한다.
3. 필요한 데이터만 메모리에 로드해 처리한다.(cf 컬렉션은 모든 데이터를 메모리에 로드해 처리)
4. iterator처럼 데이터에 1번만 접근한다.(추가적인 접근을 위해서는 스트림을 새로 생성해 접근)

스트림 만들기 - 컬렉션
스트림으로 작업하기 위해서 스트림을 생성해야 한다.
스트림의 소스가 될 수 있는 대상은 배열, 컬렉션, 임의의 수 등 다양하다.
컬렉션에서 자주 사용되는 Collection 인터페이스에는 stream 메서드가 정의되어 있다.
List, Set은 Collection 인터페이스를 상속 받기 때문에 stream 메서드를 사용하면 스트림을 생성할 수 있다.

스트림 만들기 - 배열
배열을 소스로 하는 스트림을 생성하는 메서드는 Stream과 Arrays 클래스에 static 메서드로 정의되어 있다.

스트림 만들기 - 특정 범위의 정수
IntStream과 LongStream은 지정된 범위의 연속된 정수를 스트림으로 생성해서 반환하는
range()와 rangeClosed() 메서드를 가지고 있다.
range()는 경계의 끝인 end가 범위에 포함되지 않고, rangeClosed()의 경우는 포함된다.

스트림 만들기 - 파일과 빈 스트림
java.nio.file.Files 클래스는 파일을 다루는데 필요한 메서드를 제공한다.
list() 메서드는 지정된 디렉토리에 있는 파일의 목록을 소스로 하는 스트림을 생성해서 반환한다.
요소가 하나도 없는 비어있는 스트림을 생성할 수 있다.
스트림에 연산을 수행한 결과가 하나도 없을 때, null 값보다는 빈 스트림을 반환하는 것이 낫다.

스트림의 연산
스트림이 제공하는 다양한 연산을 이용하면 복잡한 작업들을 간단히 처리할 수 있다.
마치 데이터베이스에 SELECT 문으로 쿼리하는 것과 동일한 느낌이다.
스트림이 제공하는 연산은 중간 연산과 최종 연산으로 분류할 수 있다.
중간 연산은 연산 결과를 스트림으로 반환하기 때문에 중간 연산을 계속 연결할 수 있다.
반면에 최종 연산은 스트림의 요소를 소모하면서 연산을 수행하므로 단 한번만 연산이 가능하다.

스트림 연산 - 중간연산
스트림의 중간연산은 서로 연결할 수 있다.

스트림 연산 - 최종연산


Optional
Optional<T>은 T 타입의 객체를 감싸는 래퍼 클래스이다.
Optional 타입의 객체에는 모든 타입의 객체를 담을 수 있다.
java8 부터 추가되었으며, NullPointerException이 발생하는 예외를 줄일 수 있다.
매번 null 비교 처리가 아닌 Optional에 정의된 메서드를 통해서 간단히 처리할 수 있다.


