멀티쓰레드와 멀티프로세스 차이점

멀티프로세스
다수의 프로세스를 실행하는 것
하나의 프로세스는 크게 코드, 데이터, 스택, 힙 4가지 영역으로 이루어져있음
하나 이상의 프로세스들을 동시에 처리(병렬)

멀티쓰레드
하나의 프로세스를 다수의 실행 단위로 나누어 실행하는 것
코드, 데이터, 힙 영역을 공유하고 있으며, Stack만 스레드 별로 가짐
스레드란 한 프로세스 내에서 동작되는 여러 실행의 흐름으로 프로세스 하나에 자원을 공유하면서 일련의 과정을 여러 개를 동시에 실행시킬 수 있는 것

프로젝트 방법론
워터폴
요구분석 → 설계 → 개발 -> 테스트 순으로 순차적으로 이어지는 흐름
워터폴 모델은 오랜 기간 사용된 기법이니만큼 적용 사례가 많고, 단계별로 정형화된 접근방식을 사용하는 이유로 기술적인 위험 요소가 적다는 장점
정해진 순서대로 각 파트의 업무가 분장되고 관리되기 때문에 프로세스 상의 마일스톤을 정하는 것이 비교적 쉬운 편이라는 것도 장점

실제로 각 단의 경계를 명확히 구분하고, 앞선 파트의 업무가 완전히 끝난 후 다음 단계를 시작하는 것이 거의 불가능하다는 문제

애자일
애자일 모델은 전체적인 플랜을 짜고 문서를 통해 주도해 나가던 과거의 방식(워터폴 모델)과 달리 앞을 예측하며 개발하지 않고,
일정한 주기를 가지고 끊임없이 프로토 타입을 만들어 내며 필요할 때마다 요구사항을 더하고 수정하여 커다란 소프트웨어를 개발해 나가는 방식
기능이 실제로 구동되는 모습을 확인하고, 수정요청을 하거나 다음 단계로 넘어가는 긴밀한 관계를 형성할 수 있는 것
고객이 수많은 변경사항을 검토해야 하는 번거로움이 발생

함수형 프로그래밍(Functional Programming)
무엇을 구현하겠다에 초점을 두어, 자료 처리를 수학적인 함수의 계산으로 취급하고
상태와 가변적인 데이터를 배제하는 프로그래밍
실행 순서를 지정할 필요가 없기 때문에 비절차형 언어

장점 : 사이드이펙트를 미연에 방지한다. 객체지향보다 코드가 간결하다.
비절차형이라 평가 시점이 중요하지 않다. 테스트가 쉽다.(1회만으로 신뢰성 보장) 데이터형에 구애받지 않는다.
단점 : 상태를 조작할 수 없다.

객체지향 프로그래밍(OOP)(Object-Oriented Programming)
객체 중심적인 사고이며, 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고,
객체 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법

추상화 : 공통적인 속성이나 기능을 묶어서 이름을 붙이는 것
캡슐화 : 데이터를 은닉하고 데이터 기능을 노출시키지 않는다
상속성 : 가장 중요한 특징. 하나의 클래스가 가진 특징(데이터, 함수)을 그대로 다른 클래스에 물려줄때 사용된다 (부모의 메소드나 변수를 사용할 수 있어요)
다형성 : 같은 함수가 있어도 매개변수에 따라 각자 다른 일을 하는 것
객체지향 프로그래밍은 모듈 재사용 등으로 인해 확장 및 유지보수에 상대적으로 용이

장점 : 코드의 재사용이 가능하다. 분석과 설계의 전환이 쉽다.
단점 : 처리 속도가 상대적으로 다소 느리다. 설계의 많은 시간이 소요되며 설계를 잘못하면 다시 처음부터 짜야한다. 테스트가 어렵다.

절차지향 프로그래밍(Procedure-Oriented Programming)
일이 진행되는 순서대로 프로그래밍을 하는 방법
장점 : 코드를 따라가며 읽기가 쉬우며 작성하기에도 쉬운 편이다. 컴퓨터의 처리구조와 비슷해 실행 속도가 빠르다.
단점 : 각각의 코드가 순서에 민감하게 연결되어있어 유지보수가 쉽지 않다. 프로그램을 분석하기가 어렵다.


해쉬

부트스트랩
mysql 장/단점
mssql 장/단점
oracle 장/단점
mariadb 장/단점

알고리즘 문제 풀기

배운알고리즘으로 테스트샘플 만들기

REST API 만들어보기

REST API
gRPC

json
일반적으로 서버에서 클라이언트로 데이터를 보낼 때 사용하는 양식.
클라이언트가 사용하는 언어에 관계 없이 통일된 데이터를 주고받을 수 있도록,
일정한 패턴을 지닌 문자열을 생성해 내보내면 클라이언트는 그를 해석해 데이터를 자기만의 방식으로 온전히 저장, 표시할 수 있게 된다.
과거 웹 초기 시절부터 사용되어 온 XML은 헤더와 태그 등의 여러 요소로 가독성이 떨어지고, 쓸데없이 용량을 잡아먹는다는 단점이 항상 지적되어 왔다.
이에 대응해 간결하고 통일된 양식으로 각광을 받고 있는 것이 JSON이다.
［］안의 것은 순서가 있는 배열,
｛｝안의 것은 속성명(흔히 이름표라고 한다)이 있는 객체를 의미하며,
객체 안에 객체를 넣을 수도 있어서 XML처럼 복잡한 구조 또한 표현이 가능

문법 오류에 민감하다.
주석을 지원하지 않는다. 그래서 설정 파일을 JSON으로 작성하는 것은 어렵다.
데이터 타입을 강제할 수 없다.

http오류
1XX
정보 전달: 요청을 받았고, 작업을 진행 중이라는 의미

2XX
성공: 이 작업을 성공적으로 받았고, 이해했으며, 받아들여졌다는 의미
200 OK: 성공적으로 처리했을 때 쓰인다. 가장 일반적으로 볼 수 있는 HTTP 상태.

3XX
리다이렉션: 이 요청을 완료하기 위해서는 리다이렉션이 이루어져야 한다는 의미

4XX
클라이언트 오류: 이 요청은 올바르지 않다는 의미
400 Bad Request(잘못된 요청): 요청 자체가 잘못되었을 때 사용하는 코드
403 Forbidden(거부됨): 서버가 요청을 거부할 때 발생
404 Not Found(찾을 수 없음): 찾는 리소스가 없다는 뜻으로, 가장 흔하게 볼 수 있는 오류 코드
408 Request Timeout(요청 시간 초과) : 요청 중 시간이 초과되었을때 사용하는 코드

5XX
서버 오류: 올바른 요청에 대해 서버가 응답할 수 없다는 의미
500 Internal Server Error(내부 서버 에러): 서버에 오류가 발생해 작업을 수행할 수 없을 때 사용
502 Bad Gateway: 게이트웨이가 연결된 서버로부터 잘못된 응답을 받았을 때 사용
503 Service Temporarily Unavailable(일시적으로 서비스를 이용할 수 없음): 서비스를 일시적으로 사용할 수 없을 때 사용
504 Gateway Timeout(게이트웨이 시간초과): 게이트웨이가 연결된 서버로부터 응답을 받을 수 없었을 때 사용


오버로딩
메서드의 이름은 같고 매개변수의 유형과 개수가 다르도록 하는 것을 의미합니다.
- 리턴값만을 다르게 갖는 오버로딩은 작성 할 수 없습니다.

오버라이딩
상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의해서 사용 하는것을 의미합니다.
- 메서드의 이름은 물론 파라메터의 갯수나 타입도 동일해야 하며, 주로 상위 클래스의 동작을 상속받은 하위 클래스에서 변경하기 위해 사용됩니다.

생성자(Constructor)

생성자는 new 연산자를 통해서 인스턴스를 생성할 때 반드시 호출이 되고 제일 먼저 실행되는 일종의 메소드(하지만 메소드와는 다르다.)이다.
생성자는 인스턴스 변수(필드 값 등)를 초기화 시키는 역할
생성자를 생략하면 컴파일러가 자동적으로 기본 생성자(Default Constructor)를 생성.
Default 생성자란 "public 클래스(){ }"를 의미

참고로 생성자의 매개변수를 다르게 지정하여 정의하는 것을 생성자 오버로딩이라고 한다.

생성자의 특징(메소드와의 차이)
생성자는 반드시 클래스명과 동일하게 정의하여야 한다. 생성자 앞에는 접근 제어자(public 등)만 올수 있다.
(메소드는 static과 같은 수식어를 작성할 수 있다.)
반환값이 없으므로 void나 자료형을 작성할 수 없다.
(메소드는 void나 자료형이 있어야 한다.)


메서드
선언
메서드는 크게 선언부와 구현부로 나뉘어짐
메서드 선언부는 반환타입, 메서드 이름, 매개변수 선언으로 구성

구현부
메서드 선언부 이후에 오는 괄호 {} 를 메서드 구현부라고 부름
메서드에서 수행해야 하는 실질적인 코드(로직)이 담겨있음
메서드의 반환타입이 void가 아닌 경우에 구현부 가장 아래에는 ‘return 반환값’이 반드시 포함되어야 함
반환값의 타입은 메서드 선언부에서 선언한 반환타입과 일치해야함 함

호출
자신이 만든 메서드 또는 라이브러리에서 이미 구현된 메서드를 호출할 수 있음
메서드를 호출하는 방법은 메서드 이름과 괄호 안에 인자 값을 넣으면 됨
인자 값은 메서드에 선언된 매개변수의 순서와 타입이 일치해야

상속
상속은 기존 정의된 클래스를 재사용해서 새로운 클래스를 작성(확장)하는 것을 의미한다.
상속을 이용하면 새로운 클래스를 정의할 때 적은 양의 코드 작성을 해도 되고, 공통적인 기능을 같이 사용할 수 있다.
자바에서 상속은 extends 키워드를 함께 사용하면 된다. 예를 들어 부모와 자식 클래스가 있다고 생각하자.
자식 클래스는 부모 클래스를 상속 받아서 부모가 사용할 수 있는 속성, 기능을 물려 받는다.
자바는 단일 상속만 가능

Object 클래스
Object 클래스는 모든 클래스 상속 계층도에서 가장 최상위에 있는 부모 클래스이다.
우리는 클래스를 정의할 때 extends 키워드를 써서 Object를 선언하지 않았다.
컴파일러는 다른 클래스를 상속 받지 않는 모든 클래스들을 자동적으로 Object 클래스를 상속 받도록 변경한다.

추상 클래스(abstract class)
추상 클래스는 abstract 키워드를 붙인 클래스이다.
다른 점으로는 추상 클래스로는 인스턴스화 해서 객체를 생성할 수 없다.
추상 클래스에는 미완성된 메서드를 포함하고 있다.
미완성 메서드란 메서드를 선언만 하고 구현부에 로직을 채우지 않은 형태를 말한다.
추상 클래스의 용도는 새로운 클래스를 작성하는데 부모 클래스로 사용되기 때문에 유용하다.
추상 클래스는 일반 클래스처럼 생성자가 있으며, 멤버변수, 메서드 모두 가질 수 있다.

인터페이스(interface)
인터페이스는 class가 아닌 interface 키워드를 사용해서 정의한다.
인터페이스 용도는 특정 기능에 대한 정의를 하는 것이다.
추상클래스와 차이점으로는 일반 메서드와 멤버 변수를 가질 수 없다.
인터페이스는 추상 메서드, 디폴트 메서드, 정적 메서드, 상수를 가질 수 있다.

추상 클래스와 인터페이스
추상 클래스와 인터페이스가 하는 일은 비슷하게 보일 수 있습니다.
다른 클래스가 추상 메서드를 구현하게 하는 역할을 하고 있기 때문입니다.
하지만 추상 클래스와 인터페이스의 존재 목적은 명확하게 다릅니다.
추상 클래스는 클래스가 상속 받아서 기능을 이용하고 확장하는데 중점이라고 하면,
인터페이스는 함수의 구현을 강제로 하게 하고 구현 객체의 같은 동작을 보장합니다.

내부 클래스 (inner class)
내부 클래스는 말 그대로 클래스 내부에 선언한 클래스이다.
클래스에 또 다른 클래스를 정의하는 이유는 두 개의 클래스가 서로 관련이 있기 때문이다.
내부 클래스에서는 감싸고 있는 클래스의 멤버 변수에 쉽게 접근이 가능하고, 외부에 있는 클래스는 내부 클래스의 존재를 감출 수 있다.

익명 클래스 (anonymous class)
익명 클래스는 이름이 없는 클래스이다. 이름이 없는 클래스를 어떻게 정의해야 할지 의문이 들 수 있을 것이다.
그리고 익명 클래스로는 클래스 이름 없이 객체를 생성할 수 있다.
익명 클래스는 클래스의 선언과 객체의 생성을 동시에 하기 때문에 한번만 사용될 수 있고, 오직 하나의 객체만을 생성하는 일회용 클래스이다.
클래스의 상속 또는 인터페이스를 구현할 수 있다.



접근 제어자 (access modifier)
접근제어자는 멤버 또는 클래스에 사용되어 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 함
접근제어자는 생략가능하며 생략했을 때는 자동으로 default 임을 뜻하게 된다. 따라서 default 일경우에는 접근제어자를 지정하지 않는다.
접근제어자가 사용될 수 있는 곳 : 클래스, 멤버변수, 메서드, 생성자
private : 같은 클래스 내에서만 접근 가능
default : 같은 패키지 내에서만 접근 가능
protected : 같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근 가능
public : 접근 제한이 없음
접근 범위 : private < default < protected < public 순으로 보다 많은 접근을 허용

접근 제어자를 이용한 캡슐화
접근 제어자를 사용하는 이유는 클래스의 내부에 선언된 데이터를 보호하기 위해서이다.
데이터가 유효한 값을 유지하도록 또는 비밀번호와 같은 데이터를 외부에서 함부로 변경하지 못하도록 하기 위해서는
외부로부터의 접근을 제한하는 것이 필요하다
이것을 데이터 감추기라고 하며 객체지향개념에선 캡슐화(encapsulation)이라 한다.

대상에 따라 사용할 수 있는 제어자
클래스
 public, (default), final, abstract
메서드
 모든 접근제어자, final, abstract, static
멤버변수
 모든 접근제어자, final, static
지역변수
 final

